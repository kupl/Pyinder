(*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *)

 (*
let _ =
  let target_path = "/home/wonseok/test/test.marshalled" in
  let data_oc = open_out target_path in
  let test = Core.Int.Set.empty in 
  Marshal.to_channel data_oc test [];
  close_out data_oc
*)

open Core
open Ast
open Ast.Util
open Usedef
open AttributeAnalysis

exception DuplicateException;;
exception NotEqualException;;
let weaken_typ typ =
  let weaken_typ = Type.weaken_literals typ in
  let weaken_typ =
    match weaken_typ with
    | Type.IntExpression _ -> Type.Primitive "int"
    | _ -> weaken_typ
  in
  weaken_typ

module VarType = struct
  type t = Reference.t * Type.t [@@deriving sexp, compare]

  (*
  let json_string (reference, typ) =
    Format.asprintf "(%a, %a)" Reference.pp reference Type.pp typ
    *)
end

module FunctionSet = Set.Make (Reference)
module AttrsSet = Set.Make (String)
module VarTypeMap = Map.Make (VarType)

module StoreMap = Map.Make (Reference)
module ClassMap = Map.Make (Reference)

let extract_self store =
  Refinement.Store.update_with_filter ~old_store:Refinement.Store.empty ~new_store:store ~filter:(fun reference _ -> 
    String.is_suffix ~suffix:"$self" (Reference.last reference)
  )

let extract_parameter store =
  Refinement.Store.update_with_filter ~old_store:Refinement.Store.empty ~new_store:store ~filter:(fun reference _ -> 
    Reference.is_parameter reference
  )

module ClassAttributes = struct
  type t = {
    attributes: AttrsSet.t;
    properties: AttrsSet.t;
    methods: AttrsSet.t;
  } [@@deriving sexp, equal]

  let empty = {
    attributes=AttrsSet.empty;
    properties=AttrsSet.empty;
    methods=AttrsSet.empty;
  }
  
  let pp_attrs_set format attrs_set =
    let attrs_string = (AttrsSet.fold attrs_set ~init:"{" ~f:(fun acc attr ->
      acc ^ ", " ^ attr
    )) ^ "}"
  in
  Format.fprintf format "%s" attrs_string

  let pp format { attributes; properties; methods; } =
    Format.fprintf format "
      [[ Attributes ]]\n%a\n
      [[ Properties ]]\n%a\n
      [[ Methods ]]\n%a\n
    "
    pp_attrs_set attributes pp_attrs_set properties pp_attrs_set methods

  let join left right =
    {
      attributes=AttrsSet.union left.attributes right.attributes;
      properties=AttrsSet.union left.properties right.properties;
      methods=AttrsSet.union left.methods right.methods;
    }

  let add_attribute ({ attributes; _} as t) attr =
    { t with attributes=AttrsSet.add attributes attr }

  let add_property ({ properties; _} as t) prop =
    { t with properties=AttrsSet.add properties prop }

  let add_method ({ methods; _} as t) meth =
    { t with methods=AttrsSet.add methods meth }

  let total_attributes { attributes; properties; methods; } =
    AttrsSet.union_list [attributes; properties; methods;]

  let is_subset_with_total_attributes t attributes =
    AttrsSet.is_subset attributes ~of_:(total_attributes t)

end 

module ClassSummary = struct
  
  type t = { 
    store_info : Refinement.Store.t StoreMap.t;
    class_vartype: (FunctionSet.t VarTypeMap.t) ClassMap.t;
    class_info : ClassAttributes.t ClassMap.t;
    usage_attributes : AttributeStorage.t ClassMap.t;
    (*store_info: (Reference.t, Refinement.Store.t) Base.Hashtbl.t;
    class_vartype: (Reference.t, (FunctionSet.t VarTypeMap.t)) Base.Hashtbl.t;
    *)
    (*
    * 이 self varaible (reference.map.t) 는 다음과 같은 annotation (annotationMap) 이 가능하고
    * 그 annotation은 다음과 같은 함수 reference (reference.t list) 에서 온다   
    *)
  } [@@deriving sexp, equal]

  let create () = { 
    store_info=StoreMap.empty;
    class_vartype=ClassMap.empty;
    class_info=ClassMap.empty;
    usage_attributes=ClassMap.empty;
  }

  let extract_element_type store =
    (*Format.printf "[[[ BEFORE EXTRACT ELEMENT ]]] \n\n%a\n\n" Refinement.Store.pp store;*)
    let filter_element_type (typ: Type.t) =
      
      match typ with
      | Bottom | Any | Top -> false
      | _ -> true
      
    in
    let rec fold_unit u =
      let base = 
        match Refinement.Unit.base u with
        | Some base -> 
          if filter_element_type base.annotation then Some base else None
        | None -> None
      in
      let attributes = 
        Map.Tree.fold (Refinement.Unit.attributes u) ~init:(Identifier.Map.Tree.empty) ~f:(fun ~key ~data u ->
          Identifier.Map.Tree.set u ~key ~data:(fold_unit data)
        )
      in
      Refinement.Unit.create_all base attributes
    in
    let store = Refinement.Store.fold_map ~f:(fun ~key:reference ~data:unit store ->
      (*Format.printf "[ ITER ] \n\n%a \n\n%a \n\n" Reference.pp reference Refinement.Unit.pp unit;*)
      Reference.Map.set store ~key:reference ~data:(fold_unit unit)
    ) Refinement.Store.empty store
    in
    let x = Refinement.Store.update_with_filter ~old_store:Refinement.Store.empty ~new_store:store ~filter:(fun _ typ -> 
      (*Format.printf "%a \n\n%a \n\n" Reference.pp reference Annotation.pp typ;*)
        (match typ.annotation with
        | Bottom | Any | Top -> false
        | _ -> true
        )
    )
    in
    (*Format.printf "[ After Extract ] \n\n%a \n\n" Refinement.Store.pp x;*)
    x
  
  let set ({ store_info; _ } as t) ~key ~data =
    {
      t with
      store_info = StoreMap.set ~key ~data:(extract_element_type (extract_self data)) store_info;
    }

  let get { store_info; _ } ~key =
    StoreMap.find store_info key

  let add_attribute ({ class_info; _} as t) parent attr =
    let class_attributes = 
      ClassMap.find class_info parent 
      |> Option.value ~default:ClassAttributes.empty 
    in
    let data = ClassAttributes.add_attribute class_attributes attr in
    { t with 
      class_info=ClassMap.set ~key:parent ~data class_info}

  let add_property ({ class_info; _} as t) parent property =
    let class_attributes = 
      ClassMap.find class_info parent 
      |> Option.value ~default:ClassAttributes.empty 
    in
    let data = ClassAttributes.add_property class_attributes property in
    { t with 
      class_info=ClassMap.set ~key:parent ~data class_info}

  let add_method ({ class_info; _} as t) parent meth =
    let class_attributes = 
      ClassMap.find class_info parent 
      |> Option.value ~default:ClassAttributes.empty 
    in
    let data = ClassAttributes.add_method class_attributes meth in
    { t with 
      class_info=ClassMap.set ~key:parent ~data class_info}


  let add_usage_attributes ({ usage_attributes; _ } as t) class_name storage =
    let attribute_storage = 
      ClassMap.find usage_attributes class_name 
      |> Option.value ~default:AttributeStorage.empty
    in
    { t with 
      usage_attributes=ClassMap.set ~key:class_name ~data:(AttributeStorage.join attribute_storage storage) usage_attributes}

  let get_store_info { store_info; _ } class_name = 
    ClassMap.find store_info class_name |> Option.value ~default:Refinement.Store.empty

  let get_usage_attributes { usage_attributes; _ } class_name = 
    ClassMap.find usage_attributes class_name |> Option.value ~default:AttributeStorage.empty
  let get_self_attributes_tree t class_name =
    let name = Reference.create "$parameter$self" in
    get_store_info t class_name
    |> Refinement.Store.get_attributes ~name

  let meet ~global_resolution (({ store_info; _ } as t): t) class_name method_postcondition =
    let current_postcondition = StoreMap.find store_info class_name in
    match current_postcondition with
    | Some postcondition ->
      set t ~key:class_name ~data:(Refinement.Store.meet ~global_resolution postcondition method_postcondition)
    | None -> 
      set t ~key:class_name ~data:method_postcondition
    

  let outer_join ~global_resolution (({ store_info; _ } as t): t) class_name method_postcondition =
    let current_postcondition = StoreMap.find store_info class_name |> Option.value ~default:(Refinement.Store.empty) in
    if Refinement.Store.less_or_equal ~global_resolution ~left:current_postcondition ~right:Refinement.Store.empty 
    then 
      set t ~key:class_name ~data:method_postcondition
    else
      set t ~key:class_name ~data:(Refinement.Store.outer_join ~global_resolution current_postcondition method_postcondition)

    
  let join_with_merge ~global_resolution (({ store_info; _ } as t): t) class_name method_postcondition =
    (*
    여기서 postcondition의 변수 하나하나를 저장한다   
    *)
    let current_postcondition = StoreMap.find store_info class_name |> Option.value ~default:(Refinement.Store.empty) in
    set t ~key:class_name ~data:(Refinement.Store.join_with_merge ~global_resolution current_postcondition method_postcondition)

  let outer_widen ~global_resolution ({ store_info; _ } as t) class_name method_postcondition =
    let current_postcondition = StoreMap.find store_info class_name |> Option.value ~default:(Refinement.Store.empty) in
    { t with store_info = StoreMap.set ~key:class_name ~data:(
        Refinement.Store.outer_widen ~global_resolution current_postcondition method_postcondition ~iteration:0 ~widening_threshold:3
      ) store_info
    }

  let join ~global_resolution left right =
    let store_info_merge ~key data =
      let _ = key in
      match data with
      | `Left v | `Right v -> Some v
      | `Both (v1, v2) -> Some (Refinement.Store.join_with_merge ~global_resolution v1 v2)
    in

    let class_vartype_merge ~key data =
      let _ = key in
      match data with
      | `Left v | `Right v -> Some v
      | `Both (v1, v2) ->
        let vartype_map_merge ~key data =
          let _ = key in 
          (match data with
          | `Left v | `Right v -> Some v
          | `Both (v1, v2) -> Some (FunctionSet.union v1 v2)
          )
        in
        Some (VarTypeMap.merge v1 v2 ~f:vartype_map_merge)
    in

    let class_info_merge ~key data =
      let _ = key in
      match data with
      | `Left v | `Right v -> Some v
      | `Both (v1, v2) ->
        Some (ClassAttributes.join v1 v2)
    in

    let usage_attributes_merge ~key data =
      let _ = key in
      match data with
      | `Left v | `Right v -> Some v
      | `Both (v1, v2) ->
        Some (AttributeStorage.join v1 v2)
    in

    {
      store_info=StoreMap.merge left.store_info right.store_info ~f:store_info_merge;
      class_vartype=ClassMap.merge left.class_vartype right.class_vartype ~f:class_vartype_merge; 
      class_info=ClassMap.merge left.class_info right.class_info ~f:class_info_merge;
      usage_attributes = ClassMap.merge left.usage_attributes right.usage_attributes ~f:usage_attributes_merge;
    }

  let pp_functionset format functionset = 
    FunctionSet.iter ~f:(fun func_name -> 
    Format.fprintf format "%a, " Reference.pp func_name) functionset

  let pp_vartype_map format vartype_map =
    VarTypeMap.iteri ~f:(fun ~key:(var_name, typ) ~data ->
    Format.fprintf format "%a: %a => { %a }\n" Reference.pp var_name Type.pp typ pp_functionset data
  ) vartype_map

  let pp_class_vartype format { class_vartype; _ } =
    ClassMap.iteri ~f:(fun ~key ~data ->
      Format.fprintf format "[[[ Class VarType: %a ]]] \n%a\n" Reference.pp key pp_vartype_map data
    ) class_vartype
 
  let pp_store_info format { store_info; _ } =
    StoreMap.iteri ~f:(fun ~key ~data ->
      Format.fprintf format "[[[ Store Info ]]] \n %a \n -> %a \n" Reference.pp key Refinement.Store.pp data
  ) store_info

  let pp_class_info format { class_info; _ } =
    ClassMap.iteri ~f:(fun ~key ~data ->
      Format.fprintf format "[[[ Class Info: %a ]]] \n%a\n" Reference.pp key ClassAttributes.pp data
    ) class_info

  let pp_usage_attributes format { usage_attributes; _ } =
    ClassMap.iteri ~f:(fun ~key ~data ->
      Format.fprintf format "[[[ Class Usage Attrs : %a ]]] \n%a\n" Reference.pp key AttributeStorage.pp data
    ) usage_attributes

  let pp format t =
    Format.fprintf format "%a\n%a\n%a\n%a" pp_store_info t pp_class_vartype t pp_class_info t pp_usage_attributes t

    (*
  let store_info_json_string { store_info; _ } =
    let json_string =
    Hashtbl.fold store_info ~init:"{" ~f:(fun ~key ~data json_string ->
      json_string ^ (Format.asprintf {|"%a" : {%a},|} Reference.pp key Refinement.Store.to_yojson data)
    )
    in
    let json_string = String.chop_suffix_exn json_string ~suffix:"," in
    let json_string = json_string ^ "}" in
    json_string

  let function_set_json_string function_set =
    let json_string = FunctionSet.fold function_set ~init:"{" ~f:(fun json_string func_name ->
      json_string ^ (Format.asprintf {|%a,|} Reference.pp func_name)
    )
    in
    let json_string = String.chop_suffix_exn json_string ~suffix:"," in
    let json_string = json_string ^ "}" in
    json_string

  let vartype_map_json_string vartype_map =
    let json_string = VarTypeMap.fold vartype_map ~init:"{" ~f:(fun ~key ~data json_string -> 
      json_string ^ (Format.asprintf {|"%s" : %s,|} (VarType.json_string key) (function_set_json_string data))
    )
    in
    let json_string = String.chop_suffix_exn json_string ~suffix:"," in
    let json_string = json_string ^ "}" in
    json_string

  let class_vartype_json_string { class_vartype; _ } =
    let json_string =
    Hashtbl.fold class_vartype ~init:"{" ~f:(fun ~key ~data json_string ->
      json_string ^ (Format.asprintf {|"%a : %s|} Reference.pp key (vartype_map_json_string data))
    )
    in
    let json_string = String.chop_suffix_exn json_string ~suffix:"," in
    let json_string = json_string ^ "}" in
    json_string
    *)

(*

  let equal t1 t2 =
    
    StoreMap.equal (fun ref1 ref2 -> Refinement.Store.equal ref1 ref2) t1.store_info t2.store_info
    *)
    (*
  let copy t = 
    { 
      store_info = StoreMap.copy t.store_info;
      class_vartype = t.class_vartype;
    }
    *)

  let update_map_function_of_types ({ class_vartype; _ } as t) class_name vartype_map =
    let class_vartype_map = ClassMap.find class_vartype class_name |> Option.value ~default:(VarTypeMap.empty) in
    let class_vartype_map = 
      VarTypeMap.merge ~f:(fun ~key:_ data -> 
      match data with
      | `Left d | `Right d -> Some d
      | `Both (left, right) -> Some (FunctionSet.union left right)
    ) class_vartype_map vartype_map 
    in
    { t with class_vartype = ClassMap.set ~key:class_name ~data:class_vartype_map class_vartype }

  let find_map_function_of_types { class_vartype; _ } class_name var_name var_type =
    let class_vartype_map = ClassMap.find class_vartype class_name |> Option.value ~default:(VarTypeMap.empty) in
    if VarTypeMap.mem class_vartype_map (var_name, var_type)
    then VarTypeMap.find_exn class_vartype_map (var_name, var_type)  
    else FunctionSet.empty

  let find_classes_from_attributes { class_info; _ } attributes =
    ClassMap.fold class_info ~init:[] ~f:(fun ~key ~data candidate_classes ->
      if ClassAttributes.is_subset_with_total_attributes data attributes
      then key::candidate_classes
      else candidate_classes  
    )

end

module ArgTypeMap = Map.Make (Identifier)

module ArgTypes = struct
  type t = Type.t ArgTypeMap.t [@@deriving sexp]

  let create () = ArgTypeMap.empty

  let add_arg_type t ident typ =
    let modified_typ = weaken_typ typ in
    let exn_typ = ArgTypeMap.find t ident |> Option.value ~default:modified_typ in
    match exn_typ with
    | Bottom | Any | Top -> t
    | _ ->
    ArgTypeMap.set ~key:ident ~data:(Type.union [modified_typ; exn_typ]) t
(*
  let modify_arg_typ t ident typ =
    Hashtbl.set t ~key:ident ~data:typ
*)

  let equal t1 t2 =
    ArgTypeMap.equal (fun typ1 typ2 -> Type.equal typ1 typ2) t1 t2

  let join left right =
    ArgTypeMap.merge left right ~f:(fun ~key:_ data ->
      match data with
      | `Left t | `Right t -> Some t
      | `Both (t1, t2) -> Some (Type.union_join t1 t2)
    ) 

  let pp format t =
    ArgTypeMap.iteri ~f:(fun ~key ~data ->
      Format.fprintf format "%a -> %a \n" Identifier.pp key Type.pp data;
    ) t

  let get_type t ident =
    ArgTypeMap.find t ident |> Option.value ~default:Type.Bottom

  let export_to_resolution t resolution = 
    ArgTypeMap.fold ~f:(fun ~key ~data resolution ->
        Resolution.new_local resolution ~reference:(Reference.create key) ~annotation:(Annotation.create_immutable data)
    ) t ~init:resolution

end

module FunctionSummary = struct
  type t = {
    arg_types : ArgTypes.t;
    return_condition : Refinement.Store.t;
    return_types : Type.t;
    usage_attributes : AttributeStorage.t;
    possible_condition : Refinement.Store.t;
    usedef_tables : UsedefStruct.t option;
    cfg : Cfg.t option;
  } [@@deriving sexp]

  let create () = { 
    arg_types = ArgTypes.create (); 
    return_condition = Refinement.Store.empty;
    return_types = Type.Bottom; 
    usage_attributes = AttributeStorage.empty;
    possible_condition = Refinement.Store.empty; 
    usedef_tables = None;
    cfg = None;
  }

    (*
  let extract_self store =
    Refinement.Store.update_with_filter ~old_store:Refinement.Store.empty ~new_store:store ~filter:(fun reference _ -> 
      String.is_suffix ~suffix:"$self" (Reference.last reference)
    )

    
  let meet_refinement ~global_resolution self_types method_postcondition =
      Refinement.Store.meet ~global_resolution self_types method_postcondition

  let meet_type return_types actual =
    Type.union [return_types; actual]

  let meet_summary ~global_resolution {self_types=left_self_types; return_types=left_return_types;} {self_types=right_self_types; return_types=right_return_types;} =
    {
      self_types = meet_refinement ~global_resolution left_self_types right_self_types;
      return_types = meet_type left_return_types right_return_types;
    }
    *)
  let equal {arg_types=ref1; return_types=typ1; usage_attributes=use1; _ } {arg_types=ref2; return_types=typ2; usage_attributes=use2; _} =
      (ArgTypes.equal ref1 ref2) 
      && (Type.equal typ1 typ2) 
      && (AttributeStorage.equal use1 use2)

  let join ~global_resolution left right =
    (*
    * type 정보만 다를 뿐, usedef_tables와 cfg는 반드시 같아야 한다   
    *)
    let usedef_tables = 
      (match left.usedef_tables, right.usedef_tables with
      | None, None -> None
      | Some t1, Some t2 -> 
        if UsedefStruct.equal ~f:UsedefState.equal t1 t2 then Some t1 else raise NotEqualException
      | Some t, None | None, Some t -> Some t
      )
    in
    let cfg =
      match left.cfg, right.cfg with
      | None, None -> None
      | Some c1, Some c2 -> 
        if Hashtbl.equal Cfg.Node.location_insensitive_equal c1 c2 then Some c1 else raise NotEqualException
      | Some t, None | None, Some t -> Some t
      
    in

    (*Log.dump "%a\n%a\n" Refinement.Store.pp left.possible_condition Refinement.Store.pp right.possible_condition;*)

    {
      arg_types = ArgTypes.join left.arg_types right.arg_types;
      return_condition = Refinement.Store.join_with_merge ~global_resolution left.return_condition right.return_condition;
      return_types = Type.union_join left.return_types right.return_types;
      usage_attributes = AttributeStorage.join left.usage_attributes right.usage_attributes;
      possible_condition = Refinement.Store.join_with_merge ~global_resolution left.possible_condition right.possible_condition;
      usedef_tables;
      cfg;
    }

  let pp format {arg_types; return_condition; return_types; usage_attributes; possible_condition; _} =
    Format.fprintf format 
      "%a\n<Return Condition>\n%a\n\n<Return Type> %a\n\n<Usage Attributes>\n%a \n\n<Possible Condition>\n%a\n" 
      ArgTypes.pp arg_types Refinement.Store.pp return_condition Type.pp return_types AttributeStorage.pp usage_attributes Refinement.Store.pp possible_condition

  let add_arg_types ({arg_types; _} as t) arg_typ_list =
    { t with arg_types = List.fold arg_typ_list ~init:arg_types ~f:(fun arg_types (arg, typ) -> ArgTypes.add_arg_type arg_types arg typ) }

  let add_return_info ({return_types; _} as t) return_type =
    let modified_typ = weaken_typ return_type in
    let return_types = Type.union [return_types; modified_typ] in
    {t with return_types;}

  let add_usage_attributes ({usage_attributes; _ } as t) storage =
    let x = { t with usage_attributes=AttributeStorage.join usage_attributes storage} in
    x

  let set_possible_condition t possible_condition =
    { t with possible_condition=(extract_self possible_condition); }

  let set_return_condition t return_condition =
    { t with return_condition=(extract_parameter return_condition); }
 
  let set_usedef_tables t usedef_tables =
    { t with usedef_tables; }

  let set_cfg t cfg =
    { t with cfg; }

  let get_usedef_tables {usedef_tables; _} = usedef_tables

  let get_return_condition { return_condition; _ } = return_condition

  let get_usage_attributes { usage_attributes; _ } = usage_attributes

  let get_possible_condition { possible_condition; _ } = possible_condition

  let get_arg_types {arg_types; _} = arg_types

  let get_return_types {return_types; _} = return_types

  let get_cfg { cfg; _ } = cfg

  let make_map_function_of_types { possible_condition; _ }  =
    let f anno_option =
      match anno_option with
      | Some anno ->
        (match Annotation.annotation anno with
        | Type.Union t_list -> Some t_list
        | t -> Some [t]
        )
      | None -> None
    in
    let vartype_map = Refinement.Store.make_map_function_of_types possible_condition f in
    
    vartype_map

  let find_class_of_attributes ~class_summary ~class_name ~class_param { usage_attributes; _ } =
    let identifier_to_string t =
        Identifier.Set.fold t ~init:AttrsSet.empty ~f:(fun set attr -> AttrsSet.add set attr)
    in

    (* have to make proper filter *)
    let extract_class classes =
      List.nth classes 0
    in
    let usage_attributes =
      match class_name, class_param with
      | Some class_name, Some class_param ->
        ClassSummary.get_usage_attributes class_summary class_name
        |> AttributeStorage.add_prefix ~prefix:(Reference.create class_param)
        |> AttributeStorage.join usage_attributes
      | _ -> usage_attributes
    in
    AttributeStorage.map usage_attributes ~f:(fun attributes -> 
        attributes
        |> identifier_to_string
        |> ClassSummary.find_classes_from_attributes class_summary
        |> extract_class
    )
    |> LocInsensitiveExpMap.filter_map ~f:(fun v -> v)

end

module FunctionSummaryMap = Map.Make (Reference)

module FunctionTable = struct
  type t = FunctionSummary.t FunctionSummaryMap.t [@@deriving sexp]
  let create () = FunctionSummaryMap.empty

  (*let copy t = Hashtbl.copy t*)

  let equal t1 t2 =
    FunctionSummaryMap.equal (fun fs1 fs2 -> 
      FunctionSummary.equal fs1 fs2
    ) t1 t2

  let join ~global_resolution left right = 
    FunctionSummaryMap.merge left right ~f:(fun ~key:_ data ->
      match data with
      | `Left v | `Right v -> Some v
      | `Both (v1, v2) -> Some (FunctionSummary.join ~global_resolution v1 v2)
    )

  let pp format table =
    FunctionSummaryMap.iteri ~f:(fun ~key ~data ->
      Format.fprintf format "[[[ Function Info ]]] \n%a \n%a \n" Reference.pp key FunctionSummary.pp data
    ) table

  let add_arg_types t reference arg_typ_list =
    let func_summary = FunctionSummaryMap.find t reference |> Option.value ~default:(FunctionSummary.create ()) in
    let func_summary = FunctionSummary.add_arg_types func_summary arg_typ_list in
    FunctionSummaryMap.set ~key:reference ~data:func_summary t

  let add_return_info t func return_type =
    let func_summary = FunctionSummaryMap.find t func |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummaryMap.set ~key:func ~data:(FunctionSummary.add_return_info func_summary return_type) t

  let add_usage_attributes t func storage =
    let func_summary = FunctionSummaryMap.find t func |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummaryMap.set ~key:func ~data:(FunctionSummary.add_usage_attributes func_summary storage) t

  let set_return_condition t func return_condition =
    let func_summary = FunctionSummaryMap.find t func |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummaryMap.set ~key:func ~data:(FunctionSummary.set_return_condition func_summary return_condition) t

  let set_possible_condition t func possible_condition =
    let func_summary = FunctionSummaryMap.find t func |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummaryMap.set ~key:func ~data:(FunctionSummary.set_possible_condition func_summary possible_condition) t

  let set_usedef_tables t func usedef_tables =
    let func_summary = FunctionSummaryMap.find t func |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummaryMap.set ~key:func ~data:(FunctionSummary.set_usedef_tables func_summary usedef_tables) t

  let set_cfg t func cfg =
    let func_summary = FunctionSummaryMap.find t func |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummaryMap.set ~key:func ~data:(FunctionSummary.set_cfg func_summary cfg) t

  let get_usedef_tables t func_name =
    let func_summary = FunctionSummaryMap.find t func_name |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummary.get_usedef_tables func_summary

  let get_return_condition t func_name =
    let func_summary = FunctionSummaryMap.find t func_name |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummary.get_return_condition func_summary

  let get_usage_attributes t func_name =
    let func_summary = FunctionSummaryMap.find t func_name |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummary.get_usage_attributes func_summary

  let get_possible_condition t func_name =
    let func_summary = FunctionSummaryMap.find t func_name |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummary.get_possible_condition func_summary

  let get_func_arg_types t func_name =
    let func_summary = FunctionSummaryMap.find t func_name |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummary.get_arg_types func_summary

  let get_func_return_types t func_name =
    let func_summary = FunctionSummaryMap.find t func_name |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummary.get_return_types func_summary

  let get_cfg t func_name =
    let func_summary = FunctionSummaryMap.find t func_name |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummary.get_cfg func_summary

  let make_map_function_of_types t class_name =
    (*
    make reference + type => function map   
    *)
    let vartype_map = VarTypeMap.empty in

    FunctionSummaryMap.fold ~f:(fun ~key:func_name ~data vartype_map ->
      if Reference.is_contain ~base:func_name ~target:class_name then
        let candidates_vartype = FunctionSummary.make_map_function_of_types data in
        List.fold candidates_vartype ~init:vartype_map ~f:(fun vartype_map (str_list, anno) -> 
          VarTypeMap.update vartype_map (Reference.create_from_list str_list, Option.value_exn anno) ~f:(fun func_set -> 
            FunctionSet.add (Option.value func_set ~default:FunctionSet.empty) func_name
          ) 
        )
      else
        vartype_map
    ) t ~init:vartype_map
    (*
    Hashtbl.fold t ~init:vartype_map ~f:(fun ~key:func_name ~data vartype_map ->
      if Reference.is_contain ~base:func_name ~target:class_name then
        let candidates_vartype = FunctionSummary.make_map_function_of_types data in
        List.fold candidates_vartype ~init:vartype_map ~f:(fun vartype_map (str_list, anno) -> 
          VarTypeMap.update (Reference.create_from_list str_list, Option.value_exn anno) (fun func_set_opt -> 
            Some (FunctionSet.add func_name (Option.value func_set_opt ~default:FunctionSet.empty))
          ) vartype_map
        )
      else
        vartype_map
    )
    *)

  let find_class_of_attributes ~class_summary t func_name =
    let func_summary = FunctionSummaryMap.find t func_name |> Option.value ~default:(FunctionSummary.create ()) in
    FunctionSummary.find_class_of_attributes ~class_summary func_summary

end

module OurSummary = struct
  type t = {
    class_summary : ClassSummary.t;
    function_table : FunctionTable.t;
  }
  [@@deriving equal, sexp]

  let create () = {
    class_summary = ClassSummary.create (); 
    function_table = FunctionTable.create (); 
  }

  let class_summary {class_summary; _} = class_summary

  let set_class_summary t class_summary =
    { t with class_summary; }

  let join_with_merge_function_possiblecondition ~global_resolution ({function_table; _ } as t) func_name possiblecondition =
    let update_function_table = 
      FunctionTable.get_possible_condition function_table func_name 
      |> Refinement.Store.join_with_merge ~global_resolution possiblecondition
      |> FunctionTable.set_possible_condition function_table func_name
    in
    { t with function_table=update_function_table }

    (*
  let copy {class_summary; function_table; current_function; current_possiblecondition } = 
    {
      class_summary = ClassSummary.copy class_summary;
      function_table = FunctionTable.copy function_table;
      current_function;
      current_possiblecondition
    }
    *)
  
  let equal {class_summary=cs1; function_table=ft1; _} {class_summary=cs2; function_table=ft2; _} =
    (ClassSummary.equal cs1 cs2) && (FunctionTable.equal ft1 ft2)

  let join ~global_resolution left right = 
    {
      class_summary = ClassSummary.join ~global_resolution left.class_summary right.class_summary;
      function_table = FunctionTable.join ~global_resolution left.function_table right.function_table;
    }

  let pp_class format {class_summary; _} =
    Format.fprintf format "%a" ClassSummary.pp class_summary
  let pp_func format {function_table; _} = 
    Format.fprintf format "%a" FunctionTable.pp function_table

  let pp formatter t =
    Format.fprintf formatter "%a\n\n%a" pp_class t pp_func t

  let add_arg_types ({ function_table; _} as t) reference arg_typ_list =
    { t with function_table = FunctionTable.add_arg_types function_table reference arg_typ_list }

  let add_return_info ({function_table; _} as t) func_name return_type =
    { t with function_table = FunctionTable.add_return_info function_table func_name return_type }

  let add_usage_attributes ?class_name ?class_var {class_summary; function_table; } func_name storage =
    let class_summary =
      match class_name, class_var with
      | Some class_name, Some class_var ->
        let filtered_storage = AttributeStorage.filter_by_prefix storage ~prefix:(Reference.create class_var) in
        ClassSummary.add_usage_attributes class_summary class_name filtered_storage
      | _ -> class_summary
    in
    (*let class_summary =  in*)
    let function_table = FunctionTable.add_usage_attributes function_table func_name storage in
    { class_summary; function_table; }

  let set_return_condition ({function_table; _} as t) func_name return_condition =
    { t with function_table=FunctionTable.set_return_condition function_table func_name return_condition }

  let set_possible_condition ({function_table; _} as t) func_name possible_condition =
    { t with function_table=FunctionTable.set_possible_condition function_table func_name possible_condition }
  let set_usedef_tables ({function_table; _} as t) func_name usedef_tables =
    { t with function_table=FunctionTable.set_usedef_tables function_table func_name usedef_tables }

  let set_cfg ({function_table; _} as t) func_name cfg =
    { t with function_table=FunctionTable.set_cfg function_table func_name cfg }

  let get_usedef_tables {function_table; _} func_name = 
    FunctionTable.get_usedef_tables function_table func_name
  
  let get_return_condition {function_table; _} func_name =
    FunctionTable.get_return_condition function_table func_name

  let get_usage_attributes_from_func { function_table; _ } func_name =
    FunctionTable.get_usage_attributes function_table func_name

  let get_possible_condition {function_table; _} func_name = 
    FunctionTable.get_possible_condition function_table func_name

  let get_func_arg_types {function_table; _} func_name =
    FunctionTable.get_func_arg_types function_table func_name

  let get_func_return_types {function_table; _} func_name =
    FunctionTable.get_func_return_types function_table func_name

  let get_cfg {function_table; _} func_name =
    FunctionTable.get_cfg function_table func_name

  let make_map_function_of_types { function_table; _ } class_name =
    FunctionTable.make_map_function_of_types function_table class_name

  let add_class_attribute ({class_summary; _} as t) parent attr =
    { t with class_summary = ClassSummary.add_attribute class_summary parent attr }

  let add_class_property ({class_summary; _} as t) parent property =
    { t with class_summary = ClassSummary.add_property class_summary parent property }

  let add_class_method ({class_summary; _} as t) parent meth =
    { t with class_summary = ClassSummary.add_method class_summary parent meth }

  let get_usage_attributes_from_class { class_summary; _ } class_name = 
    ClassSummary.get_usage_attributes class_summary class_name

  let get_self_attributes_tree { class_summary; _ } class_name = 
    ClassSummary.get_self_attributes_tree class_summary class_name
  
  let update_map_function_of_types ({ class_summary; _ } as t) class_name vartype_map =
    { t with class_summary = ClassSummary.update_map_function_of_types class_summary class_name vartype_map }

  let search_suspicious_variable t ~global_resolution parent =
    (*let usedef_table = get_usedef_table t func_name |> Option.value ~default:UsedefState.bottom in*)
    let possible_condition = ClassSummary.get t.class_summary ~key:parent in
    match possible_condition with
    | None -> []
    | Some possible_condition -> 
      let total_annotation = Refinement.Store.combine_join_with_merge ~global_resolution possible_condition in
      
      (* split each variables and types *)
      let f ~key ~data sofar = 
        let rec split_attrs (target_unit: Refinement.Unit.t)  = 
          let cand_attrs = Identifier.Map.Tree.fold (Refinement.Unit.attributes target_unit) ~init:[] ~f:(fun ~key:attr ~data:inner_unit cand -> 
            let cand_attrs = split_attrs inner_unit in
            cand@(List.map cand_attrs ~f:(fun cand_attr -> Identifier.Map.Tree.add Identifier.Map.Tree.empty ~key:attr ~data:cand_attr))
          )
          in
          if List.is_empty cand_attrs 
          then 
            let new_base_list =
              let new_anno_list =
                match (Refinement.Unit.base target_unit) with
                | None -> [None]
                | Some anno ->
                  (match Annotation.annotation anno with
                  | Type.Union t_list ->  List.map t_list ~f:(fun t -> Some (Annotation.create_mutable t))
                  | _ -> [Some anno]
                  )
              in
              List.map new_anno_list ~f:(fun new_anno -> Refinement.Unit.create_all new_anno Identifier.Map.Tree.empty)
            in
            new_base_list
          else
          List.map cand_attrs ~f:(fun cand_attr -> 
            match cand_attr with
            | `Duplicate -> raise DuplicateException
            | `Ok cand_attr -> 
            (*  
            Identifier.Map.Tree.iteri cand_attr ~f:(fun ~key ~data -> Log.dump "cand_attr %s >>> %a" key Refinement.Unit.pp data);
            *)
              Refinement.Unit.create_all (Refinement.Unit.base target_unit) cand_attr)
        in
        let candidates = split_attrs data in
        sofar@(List.map candidates ~f:(fun cand -> Reference.Map.set Reference.Map.empty ~key ~data:cand ))
      in

      let candidates = Reference.Map.fold total_annotation ~init:[] ~f:f in
      (*
      List.iter candidates ~f:(fun cand -> Reference.Map.iteri cand ~f:(fun ~key ~data -> Format.printf "%a -> %a\n" Reference.pp key Refinement.Unit.pp data));
      *)
      candidates

  let find_class_of_attributes ?class_name ?class_param { class_summary; function_table; } func_name  =
    FunctionTable.find_class_of_attributes ~class_summary ~class_name ~class_param function_table func_name
end

let final_summary = "Pyinder.finalSummary"
let check_dir : string -> bool 
= fun path ->
  match Sys.is_directory path with
  | `Yes -> true
  | _ -> false

let check_and_make_dir : string -> unit
= fun path ->
  if check_dir path then ()
  else Unix.mkdir path

(*
let check_file : string -> bool
= fun path ->
match Sys.file_exists path with
| `Yes -> true
| _ -> false
  *)
  
let data_path = ref ""

let set_data_path (configuration: Configuration.Analysis.t) =
  if String.equal !data_path "" then
    data_path :=
      (List.nth_exn configuration.source_paths 0 
      |> SearchPath.get_root
      |> PyrePath.show) ^ "/pyinder_analysis"


let our_model = ref (OurSummary.create ());;

let cache = ref false;;

let is_search_mode = String.equal "search"

let is_inference_mode = String.equal "inference"

let single_errors = ref [];;

let global_resolution = ref None;;

let save_mode (mode: string) =
  check_and_make_dir !data_path;
  let target_path = !data_path ^ "/mode" ^ ".marshalled" in
  let data_out = open_out target_path in
  let sexp = String.sexp_of_t mode in
  Marshal.to_channel data_out sexp [];
  close_out data_out

let load_mode () =
  let data_in = open_in (!data_path ^ "/mode" ^ ".marshalled") in
  let mode = String.t_of_sexp (Marshal.from_channel data_in) in
  close_in data_in;
  mode

let save_summary (summary: OurSummary.t) func_name =
  check_and_make_dir !data_path;
  let target_path = !data_path ^ "/" ^ (Reference.show func_name) ^ ".marshalled" in
  let data_out = open_out target_path in
  let sexp = OurSummary.sexp_of_t summary in
  Marshal.to_channel data_out sexp [];
  close_out data_out

let load_summary func_name =
  let filename = !data_path ^ "/" ^ (Reference.show func_name) ^ ".marshalled" in
  
  match Sys.file_exists filename with
  | `Yes ->
      let data_in = open_in filename in
      let our_summary = OurSummary.t_of_sexp (Marshal.from_channel data_in) in
      close_in data_in;
      our_summary
  | _ ->
    OurSummary.create ()

let load_all_summary global_resolution =
  if !cache then
    ()
  else
  (
    cache := true;
    let list_files = Sys.readdir !data_path |> Array.to_list in 
    our_model := List.fold list_files ~init:(OurSummary.create ()) ~f:(fun summary file -> 
      if String.equal file "mode.marshalled" then summary
      else
      (
        let data_in = open_in (!data_path ^ "/" ^ file) in
        let other_summary = OurSummary.t_of_sexp (Marshal.from_channel data_in) in
        close_in data_in;
        OurSummary.join ~global_resolution summary other_summary
      )
    )
  )

let select_our_model func_name =
  if is_inference_mode (load_mode ()) then
    load_summary func_name
  else 
    !our_model

